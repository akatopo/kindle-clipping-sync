{
  "!name": "node_modules/ramda/dist/ramda.js",
  "!define": {
    "R.compose.!ret": {
      "!type": "fn(a0: ?, a1: ?, a2: ?, a3: ?, a4: ?, a5: ?, a6: ?, a7: ?, a8: ?, a9: ?) -> ?",
      "!span": "2525[82:19]-2640[84:13]"
    }
  },
  "R": {
    "__": {
      "@@functional/placeholder": {
        "!type": "bool",
        "!span": "1003[35:15]-1029[35:41]"
      },
      "!span": "286615[8510:8]-286617[8510:10]",
      "!doc": "A special placeholder value used to specify \"gaps\" within curried functions,\nallowing partial application of any combination of arguments, regardless of\ntheir positions.\n\nIf `g` is a curried ternary function and `_` is `R.__`, the following are\nequivalent:\n\n  - `g(1, 2, 3)`\n  - `g(_, 2, 3)(1)`\n  - `g(_, _, 3)(1)(2)`\n  - `g(_, _, 3)(1, 2)`\n  - `g(_, 2, _)(1, 3)`\n  - `g(_, 2)(1)(3)`\n  - `g(_, 2)(1, 3)`\n  - `g(_, 2)(_, 3)(1)`\n\n@constant\n@memberOf R\n@since v0.6.0\n@category Function\n@example\n\n     var greet = R.replace('{name}', R.__, 'Hello, {name}!');\n     greet('Alice'); //=> 'Hello, Alice!'"
    },
    "add": {
      "!type": "fn(a: ?, b: ?) -> ?",
      "!span": "286631[8511:8]-286634[8511:11]",
      "!doc": "Adds two values.\n\n@func\n@memberOf R\n@since v0.1.0\n@category Math\n@sig Number -> Number -> Number\n@param {Number} a\n@param {Number} b\n@return {Number}\n@see R.subtract\n@example\n\n     R.add(2, 3);       //=>  5\n     R.add(7)(10);      //=> 17"
    },
    "addIndex": {
      "!type": "fn(a: ?) -> ?",
      "!span": "286649[8512:8]-286657[8512:16]",
      "!doc": "Returns a function that always returns the given value. Note that for\nnon-primitives the value returned is a reference to the original value.\n\nThis function is known as `const`, `constant`, or `K` (for K combinator) in\nother languages and libraries.\n\n@func\n@memberOf R\n@since v0.1.0\n@category Function\n@sig a -> (* -> a)\n@param {*} val The value to wrap in a function\n@return {Function} A Function :: * -> val.\n@example\n\n     var t = R.always('Tee');\n     t(); //=> 'Tee'"
    },
    "adjust": {
      "!type": "fn(a: ?, b: ?, c: ?) -> ?",
      "!span": "286677[8513:8]-286683[8513:14]",
      "!doc": "Applies a function to the value at the given index of an array, returning a\nnew copy of the array with the element at the given index replaced with the\nresult of the function application.\n\n@func\n@memberOf R\n@since v0.14.0\n@category List\n@sig (a -> a) -> Number -> [a] -> [a]\n@param {Function} fn The function to apply.\n@param {Number} idx The index.\n@param {Array|Arguments} list An array-like object whose value\n       at the supplied index will be replaced.\n@return {Array} A copy of the supplied array-like object with\n        the element at index `idx` replaced with the value\n        returned by applying `fn` to the existing element.\n@see R.update\n@example\n\n     R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]\n     R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]"
    },
    "compose": {
      "!type": "fn() -> ?",
      "!span": "287243[8537:8]-287250[8537:15]",
      "!doc": "Performs right-to-left function composition. The rightmost function may have\nany arity; the remaining functions must be unary.\n\n**Note:** The result of compose is not automatically curried.\n\n@func\n@memberOf R\n@since v0.1.0\n@category Function\n@sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)\n@param {...Function} functions\n@return {Function}\n@see R.pipe\n@example\n\n     var f = R.compose(R.inc, R.negate, Math.pow);\n\n     f(3, 4); // -(3^4) + 1"
    },
    "composeK": {
      "!type": "fn() -> ?",
      "!span": "287269[8538:8]-287277[8538:16]",
      "!doc": "Returns the right-to-left Kleisli composition of the provided functions,\neach of which must return a value of a type supported by [`chain`](#chain).\n\n`R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.\n\n@func\n@memberOf R\n@since v0.16.0\n@category Function\n@sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)\n@param {...Function}\n@return {Function}\n@see R.pipeK\n@example\n\n     //  parseJson :: String -> Maybe *\n     //  get :: String -> Object -> Maybe *\n\n     //  getStateCode :: Maybe String -> Maybe String\n     var getStateCode = R.composeK(\n       R.compose(Maybe.of, R.toUpper),\n       get('state'),\n       get('address'),\n       get('user'),\n       parseJson\n     );\n\n     getStateCode(Maybe.of('{\"user\":{\"address\":{\"state\":\"ny\"}}}'));\n     //=> Just('NY')\n     getStateCode(Maybe.of('[Invalid JSON]'));\n     //=> Nothing()"
    },
    "composeP": {
      "!type": "fn() -> ?",
      "!span": "287297[8539:8]-287305[8539:16]",
      "!doc": "Performs right-to-left composition of one or more Promise-returning\nfunctions. The rightmost function may have any arity; the remaining\nfunctions must be unary.\n\n@func\n@memberOf R\n@since v0.10.0\n@category Function\n@sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)\n@param {...Function} functions\n@return {Function}\n@see R.pipeP\n@example\n\n     //  followersForUser :: String -> Promise [User]\n     var followersForUser = R.composeP(db.getFollowers, db.getUserById);"
    },
    "pipe": {
      "!type": "fn() -> ?",
      "!span": "290349[8660:8]-290353[8660:12]",
      "!doc": "Performs left-to-right function composition. The leftmost function may have\nany arity; the remaining functions must be unary.\n\nIn some libraries this function is named `sequence`.\n\n**Note:** The result of pipe is not automatically curried.\n\n@func\n@memberOf R\n@since v0.1.0\n@category Function\n@sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)\n@param {...Function} functions\n@return {Function}\n@see R.compose\n@example\n\n     var f = R.pipe(Math.pow, R.negate, R.inc);\n\n     f(3, 4); // -(3^4) + 1"
    },
    "pipeK": {
      "!type": "fn() -> ?",
      "!span": "290369[8661:8]-290374[8661:13]",
      "!doc": "Returns the left-to-right Kleisli composition of the provided functions,\neach of which must return a value of a type supported by [`chain`](#chain).\n\n`R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.\n\n@func\n@memberOf R\n@since v0.16.0\n@category Function\n@sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)\n@param {...Function}\n@return {Function}\n@see R.composeK\n@example\n\n     //  parseJson :: String -> Maybe *\n     //  get :: String -> Object -> Maybe *\n\n     //  getStateCode :: Maybe String -> Maybe String\n     var getStateCode = R.pipeK(\n       parseJson,\n       get('user'),\n       get('address'),\n       get('state'),\n       R.compose(Maybe.of, R.toUpper)\n     );\n\n     getStateCode(Maybe.of('{\"user\":{\"address\":{\"state\":\"ny\"}}}'));\n     //=> Just('NY')\n     getStateCode(Maybe.of('[Invalid JSON]'));\n     //=> Nothing()"
    },
    "pipeP": {
      "!type": "fn() -> ?",
      "!span": "290391[8662:8]-290396[8662:13]",
      "!doc": "Performs left-to-right composition of one or more Promise-returning\nfunctions. The leftmost function may have any arity; the remaining functions\nmust be unary.\n\n@func\n@memberOf R\n@since v0.10.0\n@category Function\n@sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)\n@param {...Function} functions\n@return {Function}\n@see R.composeP\n@example\n\n     //  followersForUser :: String -> Promise [User]\n     var followersForUser = R.pipeP(db.getUserById, db.getFollowers);"
    },
    "reduceBy": {
      "!type": "fn() -> ?",
      "!span": "290711[8675:8]-290719[8675:16]",
      "!doc": "Groups the elements of the list according to the result of calling\nthe String-returning function `keyFn` on each element and reduces the elements\nof each group to a single value via the reducer function `valueFn`.\n\nThis function is basically a more general `groupBy` function.\n\n@func\n@memberOf R\n@since v0.20.0\n@category List\n@sig (b -> String) -> ((a, b) -> a) -> a -> [b] -> {String: a}\n@param {Function} keyFn The function that maps the list's element into a key.\n@param {Function} valueFn The function that reduces the elements of each group to a single\n       value. Receives two values, accumulator for a particular group and the current element.\n@param {*} acc The (initial) accumulator value for each group.\n@param {Array} list The array to group.\n@return {Object} An object with the output of `keyFn` for keys, mapped to the output of\n        `valueFn` for elements which produced that key when passed to `keyFn`.\n@see R.groupBy, R.reduce\n@example\n\n     var byGrade = R.reduceBy(function(student) {\n       var score = student.score;\n       return score < 65 ? 'F' :\n              score < 70 ? 'D' :\n              score < 80 ? 'C' :\n              score < 90 ? 'B' : 'A';\n     });\n     var namesByGrade = byGrade(function(acc, student) {\n       return acc.concat(student.name);\n     }, []);\n     var students = [{name: 'Lucy', score: 92},\n                     {name: 'Drew', score: 85},\n                     // ...\n                     {name: 'Bart', score: 62}];\n     namesByGrade(students);\n     // {\n     //   'A': ['Lucy'],\n     //   'B': ['Drew']\n     //   // ...,\n     //   'F': ['Bart']\n     // }"
    },
    "!span": "292653[8752:9]-292654[8752:10]",
    "all": "R.add",
    "allPass": "R.addIndex",
    "allUniq": "R.addIndex",
    "always": "R.addIndex",
    "and": "R.add",
    "any": "R.add",
    "anyPass": "R.addIndex",
    "ap": "R.add",
    "aperture": "R.add",
    "append": "R.add",
    "apply": "R.add",
    "applySpec": "R.addIndex",
    "assoc": "R.adjust",
    "assocPath": "R.adjust",
    "binary": "R.addIndex",
    "bind": "R.add",
    "both": "R.add",
    "chain": "R.add",
    "clamp": "R.adjust",
    "clone": "R.addIndex",
    "comparator": "R.addIndex",
    "cond": "R.addIndex",
    "construct": "R.addIndex",
    "constructN": "R.add",
    "contains": "R.add",
    "converge": "R.add",
    "countBy": "R.add",
    "curry": "R.addIndex",
    "curryN": "R.add",
    "defaultTo": "R.add",
    "difference": "R.add",
    "differenceWith": "R.adjust",
    "dissoc": "R.add",
    "dissocPath": "R.add",
    "divide": "R.add",
    "drop": "R.add",
    "dropLast": "R.add",
    "dropLastWhile": "R.add",
    "dropRepeats": "R.addIndex",
    "dropRepeatsWith": "R.add",
    "dropWhile": "R.add",
    "either": "R.add",
    "empty": "R.addIndex",
    "eqBy": "R.adjust",
    "eqProps": "R.adjust",
    "equals": "R.add",
    "evolve": "R.add",
    "filter": "R.add",
    "find": "R.add",
    "findIndex": "R.add",
    "findLast": "R.add",
    "findLastIndex": "R.add",
    "flatten": "R.addIndex",
    "flip": "R.addIndex",
    "forEach": "R.add",
    "fromPairs": "R.addIndex",
    "groupBy": "R.add",
    "gt": "R.add",
    "gte": "R.add",
    "has": "R.add",
    "hasIn": "R.add",
    "identical": "R.add",
    "identity": "R.addIndex",
    "ifElse": "R.adjust",
    "indexBy": "R.add",
    "indexOf": "R.add",
    "insert": "R.adjust",
    "insertAll": "R.adjust",
    "intersection": "R.add",
    "intersectionWith": "R.adjust",
    "intersperse": "R.add",
    "into": "R.adjust",
    "invert": "R.addIndex",
    "invertObj": "R.addIndex",
    "invoker": "R.add",
    "is": "R.add",
    "isArrayLike": "R.addIndex",
    "isEmpty": "R.addIndex",
    "isNil": "R.addIndex",
    "juxt": "R.addIndex",
    "keys": "R.addIndex",
    "keysIn": "R.addIndex",
    "lastIndexOf": "R.add",
    "length": "R.addIndex",
    "lens": "R.add",
    "lensIndex": "R.addIndex",
    "lensPath": "R.addIndex",
    "lensProp": "R.addIndex",
    "lift": "R.addIndex",
    "liftN": "R.add",
    "lt": "R.add",
    "lte": "R.add",
    "map": "R.add",
    "mapAccum": "R.adjust",
    "mapAccumRight": "R.adjust",
    "mapObjIndexed": "R.add",
    "match": "R.add",
    "mathMod": "R.add",
    "max": "R.add",
    "maxBy": "R.adjust",
    "mean": "R.addIndex",
    "median": "R.addIndex",
    "memoize": "R.addIndex",
    "merge": "R.add",
    "mergeAll": "R.addIndex",
    "mergeWith": "R.adjust",
    "mergeWithKey": "R.adjust",
    "min": "R.add",
    "minBy": "R.adjust",
    "modulo": "R.add",
    "multiply": "R.add",
    "nAry": "R.add",
    "negate": "R.addIndex",
    "none": "R.add",
    "not": "R.addIndex",
    "nth": "R.add",
    "nthArg": "R.addIndex",
    "objOf": "R.add",
    "of": "R.addIndex",
    "omit": "R.add",
    "once": "R.addIndex",
    "or": "R.add",
    "over": "R.adjust",
    "pair": "R.add",
    "partial": "R.add",
    "partialRight": "R.add",
    "path": "R.add",
    "pathEq": "R.adjust",
    "pathOr": "R.adjust",
    "pathSatisfies": "R.adjust",
    "pick": "R.add",
    "pickAll": "R.add",
    "pickBy": "R.add",
    "pluck": "R.add",
    "prepend": "R.add",
    "prop": "R.add",
    "propEq": "R.adjust",
    "propIs": "R.adjust",
    "propOr": "R.adjust",
    "propSatisfies": "R.adjust",
    "props": "R.add",
    "range": "R.add",
    "reduce": "R.adjust",
    "reduceRight": "R.adjust",
    "reduced": "R.addIndex",
    "reject": "R.add",
    "remove": "R.adjust",
    "repeat": "R.add",
    "replace": "R.adjust",
    "reverse": "R.addIndex",
    "scan": "R.adjust",
    "sequence": "R.add",
    "set": "R.adjust",
    "slice": "R.adjust",
    "sort": "R.add",
    "sortBy": "R.add",
    "splitAt": "R.add",
    "splitEvery": "R.add",
    "splitWhen": "R.add",
    "subtract": "R.add",
    "symmetricDifference": "R.add",
    "symmetricDifferenceWith": "R.adjust",
    "take": "R.add",
    "takeLast": "R.add",
    "takeLastWhile": "R.add",
    "takeWhile": "R.add",
    "tap": "R.add",
    "test": "R.add",
    "times": "R.add",
    "toPairs": "R.addIndex",
    "toPairsIn": "R.addIndex",
    "toString": "R.addIndex",
    "transpose": "R.addIndex",
    "traverse": "R.adjust",
    "trim": "R.addIndex",
    "tryCatch": "R.add",
    "type": "R.addIndex",
    "unapply": "R.addIndex",
    "unary": "R.addIndex",
    "uncurryN": "R.add",
    "unfold": "R.add",
    "union": "R.add",
    "unionWith": "R.adjust",
    "uniqBy": "R.add",
    "uniqWith": "R.add",
    "unless": "R.adjust",
    "until": "R.adjust",
    "update": "R.adjust",
    "useWith": "R.add",
    "values": "R.addIndex",
    "valuesIn": "R.addIndex",
    "view": "R.add",
    "when": "R.adjust",
    "where": "R.add",
    "whereEq": "R.add",
    "without": "R.add",
    "wrap": "R.add",
    "xprod": "R.add",
    "zip": "R.add",
    "zipObj": "R.add",
    "zipWith": "R.adjust"
  }
}
